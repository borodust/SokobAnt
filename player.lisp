(in-package :sokob-ant)

(defvar *player-position* (gamekit:vec2 3 3))
(defvar *pressed-directions* (list nil nil nil nil))
(defvar *last-direction* :up)
(defvar *pressed-enter* nil)
(defvar *paused* nil)

(defun move-up ()
  (when (every #'not *pressed-directions*)
    (when (eql (car *game-state*) :level)
      (setf *last-direction* :up))
    (setf (car *pressed-directions*) t)))

(defun move-down ()
  (when (every #'not *pressed-directions*)
    (when (eql (car *game-state*) :level)
      (setf *last-direction* :down))
    (setf (cadr *pressed-directions*) t)))

(defun move-right ()
  (when (every #'not *pressed-directions*)
    (when (eql (car *game-state*) :level)
      (setf *last-direction* :right))
    (setf (caddr *pressed-directions*) t)))

(defun move-left ()
  (when (every #'not *pressed-directions*)
    (when (eql (car *game-state*) :level)
      (setf *last-direction* :left))
    (setf (cadddr *pressed-directions*) t)))

(defun init-controls ()
  (gamekit:bind-button :up :pressed #'move-up)
  (gamekit:bind-button :up :repeating #'move-up)
  (gamekit:bind-button :up :released (lambda () (setf (car *pressed-directions*) nil)))
  (gamekit:bind-button :down :pressed #'move-down)
  (gamekit:bind-button :down :repeating #'move-down)
  (gamekit:bind-button :down :released (lambda () (setf (cadr *pressed-directions*) nil)))
  (gamekit:bind-button :right :pressed #'move-right)
  (gamekit:bind-button :right :repeating #'move-right)
  (gamekit:bind-button :right :released (lambda () (setf (caddr *pressed-directions*) nil)))
  (gamekit:bind-button :left :pressed #'move-left)
  (gamekit:bind-button :left :repeating #'move-left)
  (gamekit:bind-button :left :released (lambda () (setf (cadddr *pressed-directions*) nil)))
  (gamekit:bind-button :enter :pressed (lambda () (setf *pressed-enter* t)))
  (gamekit:bind-button :escape :pressed (lambda () (when (eql (car *game-state*) :level)
						     (setf *paused* t))))
  (gamekit:bind-button :r :pressed (lambda () (reset-positions))))

(defun draw-player (rotation position)
  (let ((real-x (+ (* *tile-size* (gamekit:x position)) 16))
	(real-y (+ (* *tile-size* (gamekit:y position)) 16)))
    (gamekit:scale-canvas 2.0 2.0)
    (gamekit:translate-canvas real-x real-y )
    (gamekit:rotate-canvas rotation)
    (gamekit:draw-image (gamekit:vec2 -16 -16) :player-ant)
    (gamekit:rotate-canvas (- rotation))
    (gamekit:translate-canvas (- real-x) (- real-y))
    (gamekit:scale-canvas 0.5 0.5)))

(defun push-object (object push-vector)
  (setf (caddr object)
	(calc-new-obj-pos object push-vector)))

(defun obj-can-be-pushed (object push-dir level items)
  (let ((new-pos (calc-new-obj-pos object push-dir)))
    (if (all-tiles-free level new-pos)
	t
	nil)))

(defun handle-player-move (level items)
  (if (not *paused*)
      (let ((new-x (if (caddr *pressed-directions*)
		       (1+ (gamekit:x *player-position*))
		       (if (cadddr *pressed-directions*)
			   (1- (gamekit:x *player-position*))
			   (gamekit:x *player-position*))))
	    (new-y (if (car *pressed-directions*)
		       (1+ (gamekit:y *player-position*))
		       (if (cadr *pressed-directions*)
			   (1- (gamekit:y *player-position*))
			   (gamekit:y *player-position*)))))
	(when (not (every #'not *pressed-directions*))
	  (let ((new-position (gamekit:vec2 new-x new-y)))
	    (if (eql (get-tile level new-position) :free)
		(let ((obj (get-object items new-position)))
		  (if (not obj) ; tile is completely free, player can move
		      (player-move new-x new-y)
		      (let ((push-dir (gamekit:subt new-position *player-position*)))
		      (when (obj-can-be-pushed obj push-dir
					       level items)
			(push-object obj push-dir)
			(player-move new-x new-y)))))))
	(setf *pressed-directions* (list nil nil nil nil)))
      (progn
	(setf *game-state* *paused-state*)
	(setf *paused* nil)
	(setf *selected-option* :continue))))

(defun player-move (x y)
  (setf (gamekit:x *player-position*) x)
  (setf (gamekit:y *player-position*) y)
  (gamekit:play-sound :step-sound))
